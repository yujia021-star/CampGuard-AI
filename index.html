const OPENWEATHER_API_KEY = "Fbed326c49afb2c448070bc2a8027f2b";
const SPREADSHEET_ID = "1lFRBOfNA18X_wF3QG-YqdYbCqVZ-ijd_veZmUM3rWzw";

function doGet(e) {
  try {
    let mode = (e && e.parameter && e.parameter.mode) ? e.parameter.mode : "diagnose";
    
    // --- „É¢„Éº„Éâ1: Ë®∫Êñ≠ÂÆüË°å ---
    if (mode === "diagnose") {
      let place = e.parameter.place || "ÂñúÂ§öÊñπÂ∏Ç";
      const geo = getGeo(place);
      const forecastRes = UrlFetchApp.fetch(`https://api.openweathermap.org/data/2.5/forecast?lat=${geo.lat}&lon=${geo.lon}&appid=${OPENWEATHER_API_KEY}&units=metric&lang=ja`);
      const forecastData = JSON.parse(forecastRes.getContentText());
      const bigData = searchSheetKnowledge(geo.name);
      const summary = analyzeForecast(forecastData);
      let scoreReasons = [];
      let finalScore = calculateAdvancedScore(summary, bigData, scoreReasons);

      return ContentService.createTextOutput(JSON.stringify({
        score: Math.round(finalScore),
        locationName: geo.name,
        maxWind: summary.maxWind.toFixed(1),
        maxTemp: summary.maxTemp.toFixed(1),
        minTemp: summary.minTemp.toFixed(1),
        timeline: summary.timeline,
        recommendation: generateAIAdvice(summary, bigData)
      })).setMimeType(ContentService.MimeType.JSON);
    } 
    
    // --- „É¢„Éº„Éâ2: Êó•Ë®òÊäïÁ®ø ---
    else if (mode === "postDiary") {
      const sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName("database");
      sheet.appendRow([e.parameter.place, e.parameter.topic, e.parameter.content, new Date(), e.parameter.category, ""]);
      return ContentService.createTextOutput(JSON.stringify({success: true})).setMimeType(ContentService.MimeType.JSON);
    }

    // --- „É¢„Éº„Éâ3: Â±•Ê≠¥ÂèñÂæó ---
    else if (mode === "getDiaries") {
      const sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName("database");
      const data = sheet.getDataRange().getValues();
      let diaries = [];
      for(let i=data.length-1; i>=1; i--) { 
        diaries.push({ place: data[i][0], topic: data[i][1], content: data[i][2], date: data[i][3] });
      }
      return ContentService.createTextOutput(JSON.stringify(diaries)).setMimeType(ContentService.MimeType.JSON);
    }
  } catch(e) { return ContentService.createTextOutput(JSON.stringify({error: e.toString()})).setMimeType(ContentService.MimeType.JSON); }
}

function searchSheetKnowledge(location) {
  try {
    const sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName("database");
    const data = sheet.getDataRange().getValues();
    let results = [];
    const searchKey = location.toLowerCase().replace(/\s+/g, "");
    for (let i = 1; i < data.length; i++) {
      let targetPlace = String(data[i][0]).toLowerCase().replace(/\s+/g, "");
      if (targetPlace.includes(searchKey) || searchKey.includes(targetPlace)) {
        results.push({ topic: data[i][1], content: data[i][2] });
      }
    }
    return results;
  } catch(e) { return []; }
}

function calculateAdvancedScore(summary, bigData, reasons) {
  let s = 0;
  if (summary.maxWind > 5) s += Math.pow(summary.maxWind, 1.8);
  if (summary.minTemp < 10) s += (10 - summary.minTemp) * 5;
  if (bigData.length > 0) s += 10; 
  return Math.min(s, 100);
}

function generateAIAdvice(summary, bigData) {
  let advice = "";
  if (summary.maxWind > 8) advice = "„Äê‚ö†Ô∏èÂº∑È¢®Ê≥®ÊÑè„ÄëÈ¢®„ÇíÈÅÆ„ÇãË®≠Âñ∂„Çí„ÄÇ";
  else if (summary.minTemp < 5) advice = "„Äê‚ùÑÔ∏èÈò≤ÂØíË≠¶Êàí„Äë„Çπ„Éà„Éº„Éñ„ÅÆÊ∫ñÂÇô„Çí„ÄÇ";
  else advice = "ÊØîËºÉÁöÑÁ©è„ÇÑ„Åã„Å™‰∫àÂ†±„Åß„Åô„ÄÇ";
  
  if (bigData.length > 0) advice += "\nüí°ÈÅéÂéª„ÅÆÁü•Ë¶ã„Å´Âü∫„Å•„Åç„É™„Çπ„ÇØÁÆóÂá∫Ê∏à„Åø„ÄÇ";
  return advice;
}

function analyzeForecast(data) {
  let maxW = 0, maxT = -100, minT = 100, tl = [];
  data.list.slice(0, 8).forEach(item => {
    let t = item.main.temp, w = item.wind.speed;
    tl.push({ time: new Date(item.dt * 1000).getHours() + "ÊôÇ", temp: Math.round(t), wind: w.toFixed(1), icon: item.weather[0].icon });
    if (w > maxW) maxW = w; if (t > maxT) maxT = t; if (t < minT) minT = t;
  });
  return { maxWind: maxW, maxTemp: maxT, minTemp: minT, timeline: tl };
}

function getGeo(p) {
  const res = Maps.newGeocoder().geocode(p);
  return (res.status === "OK") ? { lat: res.results[0].geometry.location.lat, lon: res.results[0].geometry.location.lng, name: res.results[0].formatted_address.replace("Êó•Êú¨„ÄÅ", "") } : { lat: 35.68, lon: 139.76, name: "Êù±‰∫¨" };
}
